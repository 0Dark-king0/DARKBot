{"file_contents":{"bot.js":{"content":"require('dotenv').config();\nconst fs = require('fs');\nconst path = require('path');\nconst express = require('express');\nconst { Client, GatewayIntentBits, REST, Routes, SlashCommandBuilder, PermissionFlagsBits } = require('discord.js');\n\nconst TOKEN = process.env.BOT_TOKEN;\nconst CLIENT_ID = process.env.CLIENT_ID || null;\nconst GUILD_ID = process.env.GUILD_ID || null;\n\nif (!TOKEN) {\n  console.error(\"Missing BOT_TOKEN in environment. Ø¶Ø¹ Ø§Ù„ØªÙˆÙƒÙ† ÙÙŠ Secrets Ø¨Ø§Ø³Ù… BOT_TOKEN\");\n  process.exit(1);\n}\n\nconst DATA_DIR = __dirname;\nfunction loadJSON(name, fallback) {\n  try {\n    const p = path.join(DATA_DIR, name);\n    if (fs.existsSync(p)) {\n      return JSON.parse(fs.readFileSync(p, 'utf8'));\n    }\n  } catch (e) {\n    console.error(\"fail load\", name, e);\n  }\n  return fallback;\n}\n\nconst responsesData = loadJSON('responses.json', { common: [], extended: [] });\nconst ideasList = loadJSON('ideas.json', []);\n\nconst CONFIG_FILE = path.join(DATA_DIR, 'config.json');\nlet config = {};\ntry { if (fs.existsSync(CONFIG_FILE)) config = JSON.parse(fs.readFileSync(CONFIG_FILE,'utf8')); } catch(e){console.error(e);}\nfunction saveConfig(){ fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2)); }\nfunction setBotRoom(guildId, channelId){ config[guildId] = config[guildId] || {}; config[guildId].botRoom = channelId; saveConfig(); }\nfunction getBotRoom(guildId){ return config[guildId] ? config[guildId].botRoom : null; }\n\nfunction rand(arr){ return arr[Math.floor(Math.random() * arr.length)]; }\n\nconst userCooldowns = new Map();\nconst COOLDOWN_MS = 5000;\n\nfunction checkCooldown(userId) {\n  const now = Date.now();\n  const last = userCooldowns.get(userId) || 0;\n  if (now - last < COOLDOWN_MS) {\n    const remaining = Math.ceil((COOLDOWN_MS - (now - last)) / 1000);\n    return { onCooldown: true, remaining };\n  }\n  userCooldowns.set(userId, now);\n  return { onCooldown: false };\n}\n\nconst client = new Client({\n  intents: [GatewayIntentBits.Guilds]\n});\n\nclient.once('ready', ()=> {\n  console.log(`âœ… Logged in as ${client.user.tag}`);\n  console.log(`ğŸ¤– Ø§Ù„Ø¨ÙˆØª Ø¬Ø§Ù‡Ø² ÙˆÙŠØ¹Ù…Ù„ Ø¨Ù†Ø¸Ø§Ù… Slash Commands ÙÙ‚Ø·`);\n});\n\nasync function registerCommands() {\n  const commands = [\n    new SlashCommandBuilder()\n      .setName('idea')\n      .setDescription('ÙŠØ¹Ø·ÙŠÙƒ ÙÙƒØ±Ø© Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹')\n      .addStringOption(option =>\n        option.setName('type')\n          .setDescription('Ù†ÙˆØ¹ Ø§Ù„ÙÙƒØ±Ø©')\n          .setRequired(true)\n          .addChoices(\n            { name: 'ğŸ“¹ ÙŠÙˆØªÙŠÙˆØ¨', value: 'ÙŠÙˆØªÙŠÙˆØ¨' },\n            { name: 'ğŸµ ØªÙŠÙƒ ØªÙˆÙƒ', value: 'ØªÙŠÙƒ ØªÙˆÙƒ' },\n            { name: 'ğŸ® Ù„Ø¹Ø¨Ø©', value: 'Ù„Ø¹Ø¨Ø©' },\n            { name: 'ğŸ“± ØªØ·Ø¨ÙŠÙ‚', value: 'ØªØ·Ø¨ÙŠÙ‚' },\n            { name: 'ğŸ“ Ù…Ù‚Ø§Ù„', value: 'Ù…Ù‚Ø§Ù„' },\n            { name: 'ğŸ² Ø¹Ø´ÙˆØ§Ø¦ÙŠ', value: 'Ø¹Ø´ÙˆØ§Ø¦ÙŠ' }\n          ))\n      .toJSON(),\n    \n    new SlashCommandBuilder()\n      .setName('greet')\n      .setDescription('Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ ØªØ­ÙŠØ© Ù…Ù† Ø§Ù„Ø¨ÙˆØª')\n      .addStringOption(option =>\n        option.setName('greeting')\n          .setDescription('Ù†ÙˆØ¹ Ø§Ù„ØªØ­ÙŠØ©')\n          .setRequired(false)\n          .addChoices(\n            { name: 'ğŸ‘‹ Ø³Ù„Ø§Ù…', value: 'Ø³Ù„Ø§Ù…' },\n            { name: 'ğŸŒ… ØµØ¨Ø§Ø­', value: 'ØµØ¨Ø§Ø­' },\n            { name: 'ğŸŒ™ Ù…Ø³Ø§Ø¡', value: 'Ù…Ø³Ø§Ø¡' },\n            { name: 'â“ ÙƒÙŠÙ Ø­Ø§Ù„Ùƒ', value: 'Ø­Ø§Ù„' }\n          ))\n      .toJSON(),\n    \n    new SlashCommandBuilder()\n      .setName('advice')\n      .setDescription('Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØµÙŠØ­Ø© Ø£Ùˆ Ø±Ø¯ Ù…Ø­ÙØ²')\n      .addStringOption(option =>\n        option.setName('topic')\n          .setDescription('Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹')\n          .setRequired(false)\n          .addChoices(\n            { name: 'ğŸ’ª ØªØ­ÙÙŠØ²', value: 'ØªØ­ÙÙŠØ²' },\n            { name: 'ğŸ“š ØªØ¹Ù„Ù…', value: 'ØªØ¹Ù„Ù…' },\n            { name: 'ğŸ’» Ø¨Ø±Ù…Ø¬Ø©', value: 'Ø¨Ø±Ù…Ø¬Ø©' },\n            { name: 'ğŸ¨ ØªØµÙ…ÙŠÙ…', value: 'ØªØµÙ…ÙŠÙ…' },\n            { name: 'ğŸ¯ Ù†ØµÙŠØ­Ø© Ø¹Ø§Ù…Ø©', value: 'Ù†ØµÙŠØ­Ø©' },\n            { name: 'ğŸ˜Œ Ø±Ø§Ø­Ø© Ù†ÙØ³ÙŠØ©', value: 'Ø±Ø§Ø­Ø©' }\n          ))\n      .toJSON(),\n    \n    new SlashCommandBuilder()\n      .setName('help')\n      .setDescription('Ø´Ø±Ø­ ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª')\n      .toJSON(),\n    \n    new SlashCommandBuilder()\n      .setName('setbotroom')\n      .setDescription('ÙŠØ­Ø¯Ø¯ Ø±ÙˆÙ… Ø§Ù„Ø¨ÙˆØª (Ù„Ù„Ø£Ø¯Ù…Ù† ÙÙ‚Ø·)')\n      .addChannelOption(opt => opt.setName('channel').setDescription('Ø§Ø®ØªØ± Ø§Ù„Ø±ÙˆÙ…').setRequired(true))\n      .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild)\n      .toJSON()\n  ];\n\n  const rest = new REST({ version: '10' }).setToken(TOKEN);\n  try {\n    console.log('â³ Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£ÙˆØ§Ù…Ø±...');\n    if (GUILD_ID && CLIENT_ID) {\n      await rest.put(Routes.applicationGuildCommands(CLIENT_ID, GUILD_ID), { body: commands });\n      console.log('âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£ÙˆØ§Ù…Ø± ÙÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ± Ø§Ù„Ù…Ø­Ø¯Ø¯');\n    } else if (CLIENT_ID) {\n      await rest.put(Routes.applicationCommands(CLIENT_ID), { body: commands });\n      console.log('âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø¨Ø´ÙƒÙ„ Ø¹Ø§Ù… (Ù‚Ø¯ ØªØ³ØªØºØ±Ù‚ Ø­ØªÙ‰ Ø³Ø§Ø¹Ø© Ù„Ù„Ø¸Ù‡ÙˆØ±)');\n    } else {\n      console.warn('âš ï¸ CLIENT_ID ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ØŒ Ù„Ù† ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£ÙˆØ§Ù…Ø±. Ø£Ø¶Ù CLIENT_ID ÙÙŠ Secrets.');\n    }\n  } catch(e) {\n    console.error('âŒ ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£ÙˆØ§Ù…Ø±:', e);\n  }\n}\n\nclient.on('interactionCreate', async (interaction) => {\n  try {\n    if (!interaction.isChatInputCommand()) return;\n\n    const cooldown = checkCooldown(interaction.user.id);\n    if (cooldown.onCooldown) {\n      return interaction.reply({ \n        content: `â° Ø§Ù†ØªØ¸Ø± ${cooldown.remaining} Ø«Ø§Ù†ÙŠØ© Ù‚Ø¨Ù„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ù…Ø± Ø¢Ø®Ø±`, \n        ephemeral: true \n      });\n    }\n\n    if (interaction.commandName === 'idea') {\n      const type = interaction.options.getString('type');\n      let idea;\n\n      if (type === 'Ø¹Ø´ÙˆØ§Ø¦ÙŠ' || !ideasList.length) {\n        idea = ideasList.length ? rand(ideasList) : 'Ù…Ø§ÙÙŠ Ø£ÙÙƒØ§Ø± Ù…Ø­Ù…Ù‘Ù„Ø© Ø­Ø§Ù„ÙŠØ§Ù‹';\n      } else {\n        let candidates = ideasList.filter(it => it.toLowerCase().startsWith(type.toLowerCase()));\n        if (candidates.length === 0) {\n          candidates = ideasList.filter(it => it.toLowerCase().includes(type.toLowerCase()));\n        }\n        if (candidates.length === 0) {\n          idea = `Ù…Ø§ Ø­ØµÙ„Øª Ø£ÙÙƒØ§Ø± Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù€ \"${type}\". Ù‡Ø°ÙŠ ÙÙƒØ±Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©:\\n${rand(ideasList)}`;\n        } else {\n          idea = rand(candidates);\n        }\n      }\n\n      await interaction.reply({ \n        content: `ğŸ’¡ **ÙÙƒØ±Ø© ${type}:**\\n${idea}`,\n        ephemeral: false\n      });\n\n    } else if (interaction.commandName === 'greet') {\n      const greetType = interaction.options.getString('greeting') || 'Ø³Ù„Ø§Ù…';\n      let response;\n\n      if (greetType === 'Ø³Ù„Ø§Ù…') {\n        const greetings = responsesData.common.find(r => r.triggers.some(t => t.includes('Ø§Ù„Ø³Ù„Ø§Ù…')));\n        response = greetings ? rand(greetings.responses) : 'ÙˆØ¹Ù„ÙŠÙƒÙ… Ø§Ù„Ø³Ù„Ø§Ù…! ğŸ‘‹';\n      } else if (greetType === 'ØµØ¨Ø§Ø­') {\n        const greetings = responsesData.common.find(r => r.triggers.some(t => t.includes('ØµØ¨Ø§Ø­')));\n        response = greetings ? rand(greetings.responses) : 'ØµØ¨Ø§Ø­ Ø§Ù„Ù†ÙˆØ±! â˜€ï¸';\n      } else if (greetType === 'Ù…Ø³Ø§Ø¡') {\n        const greetings = responsesData.common.find(r => r.triggers.some(t => t.includes('Ù…Ø³Ø§Ø¡')));\n        response = greetings ? rand(greetings.responses) : 'Ù…Ø³Ø§Ø¡ Ø§Ù„Ø®ÙŠØ±! ğŸŒ™';\n      } else if (greetType === 'Ø­Ø§Ù„') {\n        const greetings = responsesData.common.find(r => r.triggers.some(t => t.includes('ÙƒÙŠÙ Ø­Ø§Ù„Ùƒ')));\n        response = greetings ? rand(greetings.responses) : 'Ø§Ù„Ø­Ù…Ø¯ Ù„Ù„Ù‡ Ø¨Ø®ÙŠØ±! ÙˆØ£Ù†ØªØŸ ğŸ˜Š';\n      }\n\n      await interaction.reply({ content: response, ephemeral: false });\n\n    } else if (interaction.commandName === 'advice') {\n      const topic = interaction.options.getString('topic') || 'Ù†ØµÙŠØ­Ø©';\n      let response;\n\n      const topicMap = {\n        'ØªØ­ÙÙŠØ²': ['ØªØ­ÙÙŠØ²', 'Ø­Ù…Ø§Ø³', 'Ø¯Ø§ÙØ¹'],\n        'ØªØ¹Ù„Ù…': ['ØªØ¹Ù„Ù…', 'Ø¯Ø±Ø§Ø³Ø©'],\n        'Ø¨Ø±Ù…Ø¬Ø©': ['Ø¨Ø±Ù…Ø¬Ø©', 'ÙƒÙˆØ¯', 'Ø¨Ø±Ù…Ø¬'],\n        'ØªØµÙ…ÙŠÙ…': ['ØªØµÙ…ÙŠÙ…', 'Ø¯ÙŠØ²Ø§ÙŠÙ†'],\n        'Ù†ØµÙŠØ­Ø©': ['Ù†ØµÙŠØ­Ø©', 'Ù†ØµØ­Ù†ÙŠ'],\n        'Ø±Ø§Ø­Ø©': ['ØªØ¹Ø¨Ø§Ù†', 'Ø¶Ø§ÙŠÙ‚', 'Ù…Ù„Ù„']\n      };\n\n      const keywords = topicMap[topic] || ['Ù†ØµÙŠØ­Ø©'];\n      let foundResponse = null;\n\n      for (const keyword of keywords) {\n        foundResponse = responsesData.extended.find(r => \n          r.triggers.some(t => t.toLowerCase().includes(keyword.toLowerCase()))\n        );\n        if (foundResponse) break;\n      }\n\n      response = foundResponse ? rand(foundResponse.responses) : 'Ø£ÙØ¶Ù„ Ù†ØµÙŠØ­Ø©: ÙƒÙ† Ù†ÙØ³Ùƒ ÙˆØ§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„ØªØ·ÙˆÙŠØ±! ğŸ’ª';\n\n      await interaction.reply({ content: `ğŸ’­ **${topic}:**\\n${response}`, ephemeral: false });\n\n    } else if (interaction.commandName === 'help') {\n      const helpText = `\nğŸ“– **Ø¯Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª:**\n\n**Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:**\n\nğŸ¯ \\`/idea [Ø§Ù„Ù†ÙˆØ¹]\\` - Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ ÙÙƒØ±Ø© Ø¥Ø¨Ø¯Ø§Ø¹ÙŠØ©\n   â€¢ ÙŠÙˆØªÙŠÙˆØ¨ - Ø£ÙÙƒØ§Ø± Ù…Ø­ØªÙˆÙ‰ ÙŠÙˆØªÙŠÙˆØ¨\n   â€¢ ØªÙŠÙƒ ØªÙˆÙƒ - Ø£ÙÙƒØ§Ø± ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ù‚ØµÙŠØ±Ø©\n   â€¢ Ù„Ø¹Ø¨Ø© - Ø£ÙÙƒØ§Ø± Ø£Ù„Ø¹Ø§Ø¨\n   â€¢ ØªØ·Ø¨ÙŠÙ‚ - Ø£ÙÙƒØ§Ø± ØªØ·Ø¨ÙŠÙ‚Ø§Øª\n   â€¢ Ù…Ù‚Ø§Ù„ - Ø£ÙÙƒØ§Ø± Ù…Ù‚Ø§Ù„Ø§Øª\n   â€¢ Ø¹Ø´ÙˆØ§Ø¦ÙŠ - ÙÙƒØ±Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©\n\nğŸ‘‹ \\`/greet [Ù†ÙˆØ¹]\\` - Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ ØªØ­ÙŠØ©\n   â€¢ Ø³Ù„Ø§Ù… - ØªØ­ÙŠØ© Ø¹Ø§Ù…Ø©\n   â€¢ ØµØ¨Ø§Ø­ - ØªØ­ÙŠØ© ØµØ¨Ø§Ø­ÙŠØ©\n   â€¢ Ù…Ø³Ø§Ø¡ - ØªØ­ÙŠØ© Ù…Ø³Ø§Ø¦ÙŠØ©\n   â€¢ ÙƒÙŠÙ Ø­Ø§Ù„Ùƒ - Ø³Ø¤Ø§Ù„ Ø¹Ù† Ø§Ù„Ø­Ø§Ù„\n\nğŸ’¡ \\`/advice [Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹]\\` - Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†ØµÙŠØ­Ø©\n   â€¢ ØªØ­ÙÙŠØ² - ÙƒÙ„Ù…Ø§Øª Ù…Ø­ÙØ²Ø©\n   â€¢ ØªØ¹Ù„Ù… - Ù†ØµØ§Ø¦Ø­ ØªØ¹Ù„ÙŠÙ…ÙŠØ©\n   â€¢ Ø¨Ø±Ù…Ø¬Ø© - Ù†ØµØ§Ø¦Ø­ Ø¨Ø±Ù…Ø¬ÙŠØ©\n   â€¢ ØªØµÙ…ÙŠÙ… - Ù†ØµØ§Ø¦Ø­ ØªØµÙ…ÙŠÙ…\n   â€¢ Ù†ØµÙŠØ­Ø© Ø¹Ø§Ù…Ø© - Ù†ØµØ§Ø¦Ø­ Ù…ØªÙ†ÙˆØ¹Ø©\n   â€¢ Ø±Ø§Ø­Ø© Ù†ÙØ³ÙŠØ© - ÙƒÙ„Ù…Ø§Øª Ù…Ø±ÙŠØ­Ø©\n\nâš™ï¸ \\`/setbotroom\\` - ØªØ­Ø¯ÙŠØ¯ Ø±ÙˆÙ… Ø§Ù„Ø¨ÙˆØª (Ù„Ù„Ø£Ø¯Ù…Ù†)\n\nğŸ“Œ **Ù…Ù„Ø§Ø­Ø¸Ø©:** Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† Ø¨Ù†Ø¸Ø§Ù… Slash Commands ÙÙ‚Ø·\n`;\n\n      await interaction.reply({ content: helpText, ephemeral: true });\n\n    } else if (interaction.commandName === 'setbotroom') {\n      if (!interaction.memberPermissions.has(PermissionFlagsBits.ManageGuild)) {\n        return interaction.reply({ content: 'âŒ Ù…Ø§ Ø¹Ù†Ø¯Ùƒ ØµÙ„Ø§Ø­ÙŠØ© ØªØ³ØªØ®Ø¯Ù… Ù‡Ø§Ù„Ø£Ù…Ø±.', ephemeral: true });\n      }\n      const channel = interaction.options.getChannel('channel');\n      setBotRoom(interaction.guildId, channel.id);\n      await interaction.reply({ content: `âœ… ØªÙ… ØªØ¹ÙŠÙŠÙ† Ø±ÙˆÙ… Ø§Ù„Ø¨ÙˆØª: <#${channel.id}>`, ephemeral: false });\n    }\n\n  } catch(e) { \n    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ù…Ø±:', e);\n    if (!interaction.replied && !interaction.deferred) {\n      await interaction.reply({ content: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†ÙÙŠØ° Ø§Ù„Ø£Ù…Ø±', ephemeral: true });\n    }\n  }\n});\n\n(async () => {\n  await registerCommands();\n  await client.login(TOKEN);\n})();\n\nconst app = express();\napp.get('/', (req, res) => res.send('ğŸ¤– Bot is running - Slash Commands Only'));\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => console.log(`ğŸŒ Health server listening on port ${PORT}`));\n","size_bytes":11450},"privateRoom.js":{"content":"const { SlashCommandBuilder, PermissionFlagsBits, ChannelType, PermissionsBitField } = require('discord.js');\n\nmodule.exports = {\n    data: new SlashCommandBuilder()\n        .setName('private')\n        .setDescription('Ø¥Ù†Ø´Ø§Ø¡ Ø£Ùˆ Ø­Ø°Ù ØºØ±ÙØ© Ù†ØµÙŠØ© Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø¹Ø¶Ùˆ')\n        .addSubcommand(subcommand =>\n            subcommand.setName('create')\n                .setDescription('ÙŠÙ†Ø´Ø¦ ØºØ±ÙØ© Ø®Ø§ØµØ© Ù„Ø¹Ø¶Ùˆ Ù…Ø­Ø¯Ø¯')\n                .addUserOption(option =>\n                    option.setName('member')\n                        .setDescription('Ø§Ø®ØªØ± Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØºØ±ÙØ© Ù„Ù‡')\n                        .setRequired(true)\n                )\n        )\n        .addSubcommand(subcommand =>\n            subcommand.setName('delete')\n                .setDescription('ÙŠØ­Ø°Ù Ø§Ù„ØºØ±ÙØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø¹Ø¶Ùˆ')\n                .addUserOption(option =>\n                    option.setName('member')\n                        .setDescription('Ø§Ø®ØªØ± Ø§Ù„Ø¹Ø¶Ùˆ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø­Ø°Ù ØºØ±ÙØªÙ‡')\n                        .setRequired(true)\n                )\n        ),\n    async execute(interaction) {\n        const subcommand = interaction.options.getSubcommand();\n        const member = interaction.options.getUser('member');\n        const guild = interaction.guild;\n\n        if (!member) return interaction.reply({ content: 'Ø§Ù„Ø¹Ø¶Ùˆ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯!', ephemeral: true });\n\n        const channelName = `private-${member.username.toLowerCase()}`;\n\n        if (subcommand === 'create') {\n            // ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø§Ù„ØºØ±ÙØ© Ù…ÙˆØ¬ÙˆØ¯Ø©\n            const existingChannel = guild.channels.cache.find(ch => ch.name === channelName && ch.type === ChannelType.GuildText);\n            if (existingChannel) return interaction.reply({ content: 'Ø§Ù„ØºØ±ÙØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¹Ø¶Ùˆ Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„!', ephemeral: true });\n\n            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù‚Ù†Ø§Ø©\n            const channel = await guild.channels.create({\n                name: channelName,\n                type: ChannelType.GuildText,\n                permissionOverwrites: [\n                    {\n                        id: guild.id,\n                        deny: [PermissionsBitField.Flags.ViewChannel],\n                    },\n                    {\n                        id: member.id,\n                        allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages],\n                    },\n                    {\n                        id: interaction.client.user.id,\n                        allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.ManageChannels],\n                    },\n                ],\n            });\n\n            await interaction.reply({ content: `ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ØºØ±ÙØ© Ø®Ø§ØµØ© Ù„Ù„Ø¹Ø¶Ùˆ ${member.username}: <#${channel.id}>`, ephemeral: true });\n        } else if (subcommand === 'delete') {\n            const existingChannel = guild.channels.cache.find(ch => ch.name === channelName && ch.type === ChannelType.GuildText);\n            if (!existingChannel) return interaction.reply({ content: 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØºØ±ÙØ© Ø®Ø§ØµØ© Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¹Ø¶Ùˆ!', ephemeral: true });\n\n            await existingChannel.delete();\n            await interaction.reply({ content: `ØªÙ… Ø­Ø°Ù Ø§Ù„ØºØ±ÙØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø¹Ø¶Ùˆ ${member.username}`, ephemeral: true });\n        }\n    },\n};\n","size_bytes":3461},"replit.md":{"content":"# Overview\n\nThis is a Discord bot designed for Arabic-language communities that provides automated responses and creative ideas through slash commands. The bot operates entirely through Discord's slash command system, making it simple to use and requiring minimal permissions. It includes a comprehensive response library, an ideas generator with 600+ categorized ideas, and per-guild channel configuration.\n\n**Recent Changes (Oct 2025):**\n- Converted from message-based to slash-command-only operation to avoid MESSAGE_CONTENT Intent requirement\n- Added new commands: `/greet`, `/advice`, and `/help`\n- Enhanced `/idea` command with category selection via dropdown choices\n- Removed message monitoring and processing to simplify permissions\n\n# User Preferences\n\n- Preferred communication style: Simple, everyday language\n- User name: Dark (Ø¯Ø§Ø±Ùƒ)\n- Project focus: Arabic-language Discord bot for community engagement\n\n# System Architecture\n\n## Application Structure\n\n**Single-file Node.js application**: The entire bot logic resides in `bot.js`, keeping the codebase simple and self-contained. This monolithic approach was chosen for ease of deployment on Replit and straightforward maintenance for a focused use case.\n\n**File-based data persistence**: All configuration and content data is stored in JSON files on disk rather than using a database. This design decision prioritizes:\n- Simplicity: No database setup or connection management required\n- Portability: Data travels with the code\n- Replit compatibility: Works seamlessly with Replit's filesystem\n- Trade-off: Not suitable for high-concurrency scenarios, but adequate for single-bot operations\n\n**Data files**:\n- `config.json`: Stores per-guild settings (designated bot channels)\n- `responses.json`: Contains the response library with triggers and replies (structured as `{common: [], extended: []}`)\n- `ideas.json`: Array of 600+ idea suggestions for random selection, categorized by type (ÙŠÙˆØªÙŠÙˆØ¨, ØªÙŠÙƒ ØªÙˆÙƒ, Ù„Ø¹Ø¨Ø©, ØªØ·Ø¨ÙŠÙ‚, Ù…Ù‚Ø§Ù„)\n\n## Bot Framework\n\n**Discord.js v14**: Uses the official Discord.js library for all bot interactions. The bot uses minimal gateway intents:\n- `GatewayIntentBits.Guilds`: Server/guild access only\n- **No MESSAGE_CONTENT Intent required**: Bot operates entirely through slash commands, avoiding the need for privileged intents\n\n## Command System\n\n**Slash commands** implemented using Discord.js REST API and command builders:\n\n1. **`/idea [type]`** - Generates creative ideas based on category:\n   - Options: ÙŠÙˆØªÙŠÙˆØ¨, ØªÙŠÙƒ ØªÙˆÙƒ, Ù„Ø¹Ø¨Ø©, ØªØ·Ø¨ÙŠÙ‚, Ù…Ù‚Ø§Ù„, Ø¹Ø´ÙˆØ§Ø¦ÙŠ\n   - Searches ideas.json for matching category and returns random suggestion\n   - Falls back to random idea if no matches found\n\n2. **`/greet [greeting]`** - Provides contextual greetings:\n   - Options: Ø³Ù„Ø§Ù…, ØµØ¨Ø§Ø­, Ù…Ø³Ø§Ø¡, ÙƒÙŠÙ Ø­Ø§Ù„Ùƒ\n   - Pulls responses from responses.json common greetings\n   - Returns culturally appropriate Arabic greetings\n\n3. **`/advice [topic]`** - Gives advice and motivation:\n   - Topics: ØªØ­ÙÙŠØ², ØªØ¹Ù„Ù…, Ø¨Ø±Ù…Ø¬Ø©, ØªØµÙ…ÙŠÙ…, Ù†ØµÙŠØ­Ø© Ø¹Ø§Ù…Ø©, Ø±Ø§Ø­Ø© Ù†ÙØ³ÙŠØ©\n   - Searches responses.json extended library for relevant advice\n   - Returns motivational or practical guidance\n\n4. **`/help`** - Displays comprehensive bot usage guide\n   - Shows all available commands with descriptions\n   - Ephemeral response (only visible to user)\n\n5. **`/setbotroom [channel]`** - Sets designated bot room (Admin only)\n   - Requires MANAGE_GUILD permission\n   - Stores configuration per guild in config.json\n   - Used for future per-channel features\n\n## Response Library Structure\n\n**responses.json** contains two categories:\n\n1. **common**: Basic greetings and common interactions\n   - Greetings: Ø³Ù„Ø§Ù…, ØµØ¨Ø§Ø­, Ù…Ø³Ø§Ø¡\n   - Basic responses: Ø´ÙƒØ±, ÙˆØ¯Ø§Ø¹, Ø£Ù‡Ù„Ø§\n   - Used by `/greet` command\n\n2. **extended**: Detailed advice and topic-specific responses\n   - Topics: programming, design, learning, motivation, health\n   - Rich content for `/advice` command\n   - Multiple response variations for diversity\n\n## Ideas Library Structure\n\n**ideas.json**: Array of 600+ creative ideas, each prefixed with category:\n- Format: `\"ÙŠÙˆØªÙŠÙˆØ¨: ÙÙƒØ±Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰...\"`\n- Categories cover: YouTube content, TikTok videos, game concepts, app ideas, article topics\n- Filtering logic: searches by prefix first, then by contains\n\n## Cooldown System\n\n**User-based cooldown**: 5-second cooldown per user to prevent spam\n- Tracked in memory using Map<userId, timestamp>\n- Returns friendly Arabic message with remaining time\n- Cooldown applies across all commands\n\n## Keep-Alive Mechanism\n\n**Express web server**: A minimal HTTP server runs alongside the Discord bot to satisfy Replit's always-on requirement. This prevents the Replit from sleeping due to inactivity.\n- Endpoint: `GET /` returns \"ğŸ¤– Bot is running - Slash Commands Only\"\n- Listens on port 3000 (configurable via PORT env var)\n\n## Configuration Management\n\n**Environment-based secrets**: \n- `BOT_TOKEN` (required): Discord bot authentication token\n- `CLIENT_ID` (recommended): Application ID for command registration\n- `GUILD_ID` (optional): Specific guild ID for faster command deployment\n\n**Runtime configuration updates**: The `config.json` file is read on startup and written synchronously when settings change (e.g., when setting bot room per guild). Each guild's configuration is namespaced by guild ID.\n\n## Error Handling\n\n**Graceful degradation**: \n- Missing data files return fallback values (empty arrays/objects) rather than crashing\n- JSON parsing errors are logged but don't terminate the bot\n- Interaction errors are caught and report friendly message to user\n- Command failures don't crash the bot process\n\n# External Dependencies\n\n## Discord API\n- **discord.js** (v14.14.0): Complete Discord bot framework\n- **No privileged intents required**: Works with Guilds intent only\n- Uses REST API for slash command registration\n\n## Runtime Environment\n- **Node.js** (20.x): JavaScript runtime\n- **dotenv** (v16.4.0): Environment variable management\n- **express** (v4.18.2): HTTP server for Replit keep-alive\n\n## Platform Requirements\n- **Replit Secrets**: Must configure `BOT_TOKEN` (required), recommended to add `CLIENT_ID` for command registration\n- **Discord Developer Portal**: Bot only needs basic \"Guilds\" intent enabled (no privileged intents)\n- **Bot Permissions**: Send Messages, Use Slash Commands (permissions value: 2048 for basic operation)\n\n## No Database\nThis application intentionally uses file-based storage instead of a database system. All data persistence occurs through synchronous file I/O operations on JSON files.\n\n# Development Notes\n\n## Advantages of Slash-Commands-Only Approach\n- No MESSAGE_CONTENT Intent needed (avoids Discord verification for 100+ servers)\n- Simpler permission model\n- Built-in command discovery (users can see available commands)\n- Type-safe parameter handling with Discord's choice system\n- No message parsing or regex complexity\n\n## Trade-offs\n- Less \"natural\" interaction compared to message triggers\n- Users must learn commands instead of organic conversation\n- Cannot respond to regular messages or mentions\n- Requires users to type `/` to interact\n\n## Future Enhancement Possibilities\n- Add button/select menu interactions for multi-step flows\n- Implement modal forms for complex inputs\n- Add context menu commands for message/user actions\n- Create scheduled tasks for daily ideas or motivation\n- Add statistics tracking for popular commands/ideas\n","size_bytes":7519}},"version":1}